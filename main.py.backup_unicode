#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Lightning Scalper - Fixed Main Application
‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤ load_clients_configuration ‡πÅ‡∏•‡∏∞ attribute errors
"""

import asyncio
import signal
import sys
import os
import json
import argparse
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import threading
import time
from pathlib import Path

# Add project root to Python path
PROJECT_ROOT = Path(__file__).parent.absolute()
sys.path.insert(0, str(PROJECT_ROOT))

# Import our core modules
try:
    from core.main_controller import LightningScalperController
    from core.lightning_scalper_engine import CurrencyPair
    from execution.trade_executor import ClientAccount
    from adapters.mt5_adapter import MT5Adapter
except ImportError as e:
    print(f"[X] Failed to import core modules: {e}")
    print("   Make sure all required files are in the correct directories")
    sys.exit(1)

class LightningScalperApp:
    """
    [ROCKET] Lightning Scalper Main Application
    Production application wrapper for the trading system
    """
    
    def __init__(self, config_path: Optional[str] = None):
        self.app_name = "Lightning Scalper"
        self.version = "1.0.0"
        self.config_path = config_path or "config/settings.json"
        
        # Core system
        self.controller: Optional[LightningScalperController] = None
        self.is_running = False
        self.shutdown_event = threading.Event()
        
        # Application state
        self.start_time: Optional[datetime] = None
        self.stats = {
            'startup_time': None,
            'total_runtime': timedelta(0),
            'restart_count': 0,
            'last_restart': None
        }
        
        # Setup logging
        self._setup_application_logging()
        self.logger = logging.getLogger('LightningScalperApp')
        
        # Signal handlers for graceful shutdown
        self._setup_signal_handlers()
        
        # Default configuration
        self.default_config = self._get_default_config()
        
        self.logger.info(f"[ROCKET] {self.app_name} v{self.version} initialized")
    
    def _setup_application_logging(self):
        """Setup comprehensive application logging"""
        # Create logs directory if it doesn't exist
        logs_dir = PROJECT_ROOT / "logs"
        logs_dir.mkdir(exist_ok=True)
        
        # Setup logging configuration
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        
        # Configure root logger
        logging.basicConfig(
            level=logging.INFO,
            format=log_format,
            handlers=[
                logging.FileHandler(logs_dir / 'lightning_scalper_main.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        # Create separate loggers for different components
        component_loggers = [
            'LightningScalperController',
            'EnhancedFVGDetector', 
            'TradeExecutor',
            'MT5Adapter'
        ]
        
        for logger_name in component_loggers:
            logger = logging.getLogger(logger_name)
            handler = logging.FileHandler(logs_dir / f'{logger_name.lower()}.log')
            handler.setFormatter(logging.Formatter(log_format))
            logger.addHandler(handler)
    
    def _setup_signal_handlers(self):
        """Setup signal handlers for graceful shutdown"""
        def signal_handler(signum, frame):
            signal_name = signal.Signals(signum).name
            self.logger.info(f"[SATELLITE] Received {signal_name} signal, initiating graceful shutdown...")
            self.shutdown_event.set()
        
        # Register signal handlers
        signal.signal(signal.SIGINT, signal_handler)   # Ctrl+C
        signal.signal(signal.SIGTERM, signal_handler)  # Termination signal
        
        if hasattr(signal, 'SIGHUP'):  # Unix systems only
            signal.signal(signal.SIGHUP, signal_handler)  # Hangup signal
    
    def _get_default_config(self) -> Dict[str, Any]:
        """Get default application configuration"""
        return {
            "application": {
                "name": self.app_name,
                "version": self.version,
                "debug_mode": True,  # ‡πÄ‡∏õ‡∏¥‡∏î debug mode ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
                "auto_start_trading": False,
                "max_startup_time": 60,
                "health_check_interval": 30,
                "auto_restart_on_failure": True,
                "max_restart_attempts": 3
            },
            "system": {
                "max_clients": 100,
                "data_update_interval": 1.0,
                "signal_generation_interval": 5.0,
                "auto_reconnect": True,
                "max_reconnect_attempts": 5,
                "enable_performance_monitoring": True
            },
            "risk": {
                "global_daily_loss_limit": 5000.0,
                "max_concurrent_trades": 200,
                "emergency_stop_loss_percent": 10.0,
                "max_signals_per_client_hour": 10,
                "enable_global_safety": True
            },
            "trading": {
                "default_currency_pairs": ["EURUSD", "GBPUSD", "USDJPY", "AUDUSD", "XAUUSD"],
                "default_timeframes": ["M1", "M5", "M15", "H1"],
                "min_signal_confluence": 65.0,
                "max_slippage_pips": 3.0,
                "default_risk_per_trade": 0.02,
                "allow_demo_trading": True
            },
            "logging": {
                "log_level": "INFO",
                "max_log_file_size": "100MB",
                "log_retention_days": 30,
                "enable_performance_logs": True,
                "enable_trade_logs": True
            },
            "clients": {
                "auto_load_clients": True,
                "clients_config_file": "config/clients.json"
            }
        }
    
    def load_configuration(self) -> Dict[str, Any]:
        """Load application configuration from file"""
        try:
            config_file = PROJECT_ROOT / self.config_path
            
            if config_file.exists():
                with open(config_file, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)
                
                # Merge with default config
                config = self.default_config.copy()
                self._deep_merge_config(config, file_config)
                
                self.logger.info(f"[CHECK] Configuration loaded from {config_file}")
                return config
            else:
                self.logger.warning(f"[WARNING] Config file {config_file} not found, using defaults")
                
                # Create default config file
                self._create_default_config_file(config_file)
                return self.default_config
                
        except Exception as e:
            self.logger.error(f"[X] Failed to load configuration: {e}")
            self.logger.info("[REFRESH] Using default configuration")
            return self.default_config
    
    def _deep_merge_config(self, base: Dict, update: Dict):
        """Deep merge configuration dictionaries"""
        for key, value in update.items():
            if isinstance(value, dict) and key in base and isinstance(base[key], dict):
                self._deep_merge_config(base[key], value)
            else:
                base[key] = value
    
    def _create_default_config_file(self, config_file: Path):
        """Create default configuration file"""
        try:
            config_file.parent.mkdir(parents=True, exist_ok=True)
            
            with open(config_file, 'w', encoding='utf-8') as f:
                json.dump(self.default_config, f, indent=4)
            
            self.logger.info(f"[MEMO] Created default config file: {config_file}")
            
        except Exception as e:
            self.logger.error(f"[X] Failed to create config file: {e}")
    
    def load_clients_configuration(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Load client configurations"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î clients ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if not config.get('clients', {}).get('auto_load_clients', True):
                self.logger.info("[INFO] Auto load clients disabled")
                return []
            
            # ‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå clients config
            clients_file_path = config.get('clients', {}).get('clients_config_file', 'config/clients.json')
            clients_file = PROJECT_ROOT / clients_file_path
            
            if clients_file.exists():
                with open(clients_file, 'r', encoding='utf-8') as f:
                    clients_data = json.load(f)
                
                # ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô list ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏£‡∏á‡πÜ ‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô dict ‡πÉ‡∏´‡πâ‡πÄ‡∏≠‡∏≤ key 'clients'
                if isinstance(clients_data, list):
                    final_clients = clients_data
                elif isinstance(clients_data, dict):
                    final_clients = clients_data.get('clients', clients_data)
                else:
                    final_clients = []
                
                self.logger.info(f"[CHECK] Loaded {len(final_clients)} client configurations from {clients_file}")
                return final_clients
            
            else:
                self.logger.warning(f"[WARNING] Clients file {clients_file} not found")
                # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå demo clients
                self._create_sample_clients_file(clients_file)
                return []
                
        except Exception as e:
            self.logger.error(f"[X] Failed to load clients configuration: {e}")
            return []
    
    def _create_sample_clients_file(self, clients_file: Path):
        """Create sample clients configuration file"""
        try:
            clients_file.parent.mkdir(parents=True, exist_ok=True)
            
            sample_clients = [
                {
                    "client_id": "DEMO_CLIENT_001",
                    "is_demo": True,
                    "account_info": {
                        "client_id": "DEMO_CLIENT_001",
                        "account_number": "demo_12345678",
                        "broker": "MetaTrader5_Demo",
                        "currency": "USD",
                        "balance": 10000.0,
                        "equity": 10000.0,
                        "margin": 0.0,
                        "free_margin": 10000.0,
                        "margin_level": 0.0,
                        "max_daily_loss": 200.0,
                        "max_weekly_loss": 500.0,
                        "max_monthly_loss": 1500.0,
                        "max_positions": 5,
                        "max_lot_size": 1.0,
                        "preferred_pairs": ["EURUSD", "GBPUSD", "USDJPY"],
                        "trading_sessions": ["London", "NewYork"]
                    },
                    "mt5_login": 12345678,
                    "mt5_password": "demo_password",
                    "mt5_server": "MetaQuotes-Demo",
                    "preferred_pairs": ["EURUSD", "GBPUSD", "USDJPY", "XAUUSD"],
                    "risk_multiplier": 1.0,
                    "max_signals_per_hour": 10
                }
            ]
            
            with open(clients_file, 'w', encoding='utf-8') as f:
                json.dump(sample_clients, f, indent=4, ensure_ascii=False)
            
            self.logger.info(f"[MEMO] Created sample clients file: {clients_file}")
            
        except Exception as e:
            self.logger.error(f"[X] Failed to create sample clients file: {e}")
    
    async def startup(self, config: Dict[str, Any]) -> bool:
        """Application startup sequence"""
        try:
            self.start_time = datetime.now()
            startup_start = time.time()
            
            self.logger.info("[ROCKET] Starting Lightning Scalper Application...")
            
            # 1. Initialize controller
            self.logger.info("[SATELLITE] Initializing system controller...")
            self.controller = LightningScalperController(self.config_path)
            
            # 2. Start core system
            self.logger.info("[LIGHTNING] Starting core trading system...")
            success = await self.controller.start_system()
            
            if not success:
                self.logger.error("[X] Failed to start core trading system")
                return False
            
            # 3. Load and add clients
            clients_data = self.load_clients_configuration(config)
            
            if clients_data:
                self.logger.info(f"[USERS] Loading {len(clients_data)} clients...")
                
                for client_data in clients_data:
                    try:
                        # Skip demo clients in production mode
                        if client_data.get('is_demo', False) and not config['application']['debug_mode']:
                            self.logger.info(f"‚è≠Ô∏è Skipping demo client {client_data['client_id']} (production mode)")
                            continue
                        
                        # Add client to system
                        if config['application']['debug_mode']:
                            # In debug mode, just register without MT5 connection
                            client_account = ClientAccount(**client_data['account_info'])
                            success = self.controller.trade_executor.register_client(client_account)
                            
                            if success:
                                # Also add to controller's active_clients
                                self.controller.add_client(client_account)
                                self.logger.info(f"[CHECK] Client {client_data['client_id']} registered (Debug Mode)")
                            else:
                                self.logger.warning(f"[WARNING] Failed to register client {client_data['client_id']}")
                        else:
                            # Production mode - full MT5 integration
                            client_account = ClientAccount(**client_data['account_info'])
                            success = self.controller.add_client(client_account)
                            if success:
                                self.logger.info(f"[CHECK] Client {client_data['client_id']} connected successfully")
                            else:
                                self.logger.warning(f"[WARNING] Failed to connect client {client_data['client_id']}")
                    
                    except Exception as e:
                        self.logger.error(f"[X] Error loading client {client_data.get('client_id', 'Unknown')}: {e}")
            else:
                self.logger.info("[INFO] No clients to load")
            
            # 4. Setup application monitoring
            if config['system']['enable_performance_monitoring']:
                self._start_performance_monitoring()
            
            # 5. Calculate startup time
            startup_time = time.time() - startup_start
            self.stats['startup_time'] = startup_time
            
            # 6. Final status check
            system_status = self.controller.get_system_status()
            
            self.logger.info("[CHECK] Lightning Scalper Application started successfully!")
            self.logger.info(f"   ‚è±Ô∏è Startup time: {startup_time:.2f}s")
            self.logger.info(f"   üéØ System status: {system_status.get('status', 'Unknown')}")
            self.logger.info(f"   üë• Active clients: {system_status.get('metrics', {}).get('active_clients', 0)}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"[X] Startup failed: {e}")
            return False
    
    def _start_performance_monitoring(self):
        """Start performance monitoring thread"""
        try:
            def monitoring_loop():
                while self.is_running and not self.shutdown_event.is_set():
                    try:
                        if self.controller:
                            status = self.controller.get_system_status()
                            # Log performance metrics
                            self.logger.debug(f"[PERFORMANCE] {status}")
                    except Exception as e:
                        self.logger.error(f"[X] Performance monitoring error: {e}")
                    
                    time.sleep(60)  # Monitor every minute
            
            monitor_thread = threading.Thread(target=monitoring_loop, daemon=True)
            monitor_thread.start()
            self.logger.info("[CHECK] Performance monitoring started")
            
        except Exception as e:
            self.logger.error(f"[X] Failed to start performance monitoring: {e}")
    
    async def run(self):
        """Main application run loop"""
        try:
            # Load configuration
            config = self.load_configuration()
            
            # Startup
            success = await self.startup(config)
            if not success:
                self.logger.error("[X] Failed to start Lightning Scalper")
                return
            
            self.is_running = True
            self.logger.info("[ROCKET] Lightning Scalper is running...")
            
            # Main loop
            while self.is_running and not self.shutdown_event.is_set():
                try:
                    # System health check
                    if self.controller:
                        status = self.controller.get_system_status()
                        if status.get('status') == 'ERROR':
                            self.logger.error("[X] System in error state")
                            break
                    
                    # Brief pause
                    await asyncio.sleep(1)
                    
                except KeyboardInterrupt:
                    self.logger.info("[SATELLITE] Keyboard interrupt received")
                    break
                except Exception as e:
                    self.logger.error(f"[X] Main loop error: {e}")
                    await asyncio.sleep(5)
            
        except Exception as e:
            self.logger.error(f"[X] Application run error: {e}")
        
        finally:
            await self.shutdown()
    
    async def shutdown(self):
        """Graceful application shutdown"""
        try:
            self.logger.info("[SATELLITE] Shutting down Lightning Scalper...")
            self.is_running = False
            self.shutdown_event.set()
            
            # Shutdown controller
            if self.controller:
                await self.controller.shutdown()
            
            # Calculate total runtime
            if self.start_time:
                self.stats['total_runtime'] = datetime.now() - self.start_time
                self.logger.info(f"[TIME] Total runtime: {self.stats['total_runtime']}")
            
            self.logger.info("[SATELLITE] Lightning Scalper shutdown completed")
            
        except Exception as e:
            self.logger.error(f"[X] Shutdown error: {e}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description='Lightning Scalper Trading System')
    parser.add_argument('--config', '-c', type=str, help='Configuration file path')
    parser.add_argument('--debug', '-d', action='store_true', help='Enable debug mode')
    parser.add_argument('--version', '-v', action='version', version='Lightning Scalper 1.0.0')
    
    args = parser.parse_args()
    
    # Create application instance
    app = LightningScalperApp(config_path=args.config)
    
    try:
        # Run the application
        asyncio.run(app.run())
    except KeyboardInterrupt:
        print("\n[SATELLITE] Application interrupted by user")
    except Exception as e:
        print(f"[X] Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
